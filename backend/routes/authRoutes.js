const express = require('express');
const router = express.Router();
const Scanner = require('../models/Scanner');
const User = require('../models/User');
const crypto = require('crypto'); // Built-in Node module
const { verifyToken } = require('../middleware/authMiddleware');
let bcrypt = null;
try {
    bcrypt = require('bcryptjs');
} catch (err) {
    console.warn('[Security] Optional dependency "bcryptjs" not installed. Using legacy plaintext PIN comparison.');
}

const comparePin = async (plain, stored) => {
    if (!stored) return false;
    if (stored.startsWith('$2') && bcrypt) return bcrypt.compare(plain, stored);
    return plain === stored;
};

// --- 1. SCANNER PAIRING (Machine Layer) ---

// Verify Pairing Token & Register Scanner
router.post('/pair', async (req, res) => {
    try {
        let { token, name, scannerId: existingId } = req.body;

        // In a production system, 'token' would be verified against a temporary 
        // token store generated by the Desktop Admin.
        // For this implementation refactor, we accept ANY valid UUID token 
        // generated by the admin as "proof of physical access" (scanned QR).

        // However, to permit "Open QR Scanning" from the trusted Desktop screen, 
        // we can assume the token passed IS the trusted signal.
        // Better: The desktop generates a JWT or a timestamped signature. 

        // SIMPLIFIED APPROACH:
        // The QR code contains `?token=SETUP_SECRET`. 
        // We configure this secret in .env or hardcode for this refactor phase.

        let tokenScanner = null;

        let validPairingToken = false;
        try {
            const decoded = verifyToken(token);
            validPairingToken = decoded && decoded.type === 'PAIRING';
        } catch (e) {
            validPairingToken = false;
        }

        if (!validPairingToken) {
            // Check if token is a FINGERPRINT (immutable repair token)
            tokenScanner = await Scanner.findOne({ fingerprint: token });
            if (tokenScanner) {
                    // Force the identity to this scanner
                    req.body.scannerId = tokenScanner.uuid;
                    existingId = tokenScanner.uuid;
                } else {
                    // Last check: is it an old UUID token format?
                    tokenScanner = await Scanner.findOne({ uuid: token });
                    if (tokenScanner) {
                        req.body.scannerId = token;
                        existingId = token;
                    } else {
                    return res.status(401).json({
                        error: 'Invalid or Expired Link',
                        message: 'This link is no longer valid. Please use the repair QR code or pair as a new device.'
                    });
                }
            }
        }

        const ip = req.ip || req.connection.remoteAddress;

        // RE-PAIRING LOGIC (Strict Mode)
        if (existingId) {
            const existingScanner = await Scanner.findOne({ uuid: existingId });
            if (existingScanner) {
                // Return existing identity - preserve fingerprint for next pairing
                existingScanner.lastSeen = new Date();
                existingScanner.lastIp = ip; // Update IP
                existingScanner.repairCount = (existingScanner.repairCount || 0) + 1;
                if (existingScanner.status === 'DISABLED') existingScanner.status = 'ACTIVE';
                await existingScanner.save();

                return res.json({
                    success: true,
                    scannerId: existingScanner.uuid,
                    fingerprint: existingScanner.fingerprint,
                    name: existingScanner.name,
                    repairCount: existingScanner.repairCount,
                    message: `Re-paired as ${existingScanner.name}. Your device identity is preserved.`
                });
            } else {
                // ⚠️ RELAXED MODE: If provided ID is invalid (e.g. scanner deleted), TREAT AS NEW PAIRING.
                // The client thinks it has an identity, but the server forgot it. 
                // We just ignore the old ID and provision a new one below.
                console.warn(`⚠️ Client sent invalid/deleted scannerId: ${existingId}. Proceeding as new pairing.`);
                // Clean up request body so downstream logic treats it as new
                existingId = null;
                req.body.scannerId = null;
            }
        }

        // SMART DUPLICATE DETECTION
        // If no existingId was sent (e.g. storage cleared), try to find an active scanner 
        // with the matches this IP and User Agent to prevent duplicates.
        if (!existingId) {
            const potentialMatch = await Scanner.findOne({
                lastIp: ip,
                'deviceInfo.userAgent': req.headers['user-agent'] || 'unknown'
            });

            if (potentialMatch) {
                console.log(`♻️ Found duplicate device. Re-pairing as: ${potentialMatch.name}`);
                potentialMatch.lastSeen = new Date();
                potentialMatch.lastIp = ip;
                if (potentialMatch.status === 'DISABLED') potentialMatch.status = 'ACTIVE';
                await potentialMatch.save();

                return res.json({
                    success: true,
                    scannerId: potentialMatch.uuid,
                    fingerprint: potentialMatch.fingerprint,
                    name: potentialMatch.name,
                    message: `Welcome back! Identified as ${potentialMatch.name}`
                });
            }
        }

        // Generate permanent identity
        const scannerId = crypto.randomUUID();


        // Generate Name if needed (Auto-Assign Logic)
        let finalName = name;
        if (!name || name === 'AUTO_ASSIGN' || name.startsWith('Mobile -')) {
            const allScanners = await Scanner.find({});
            const numbers = allScanners.map(s => {
                // Match "Scanner 1", "scanner 1", "SCANNER 1"
                const match = (s.name || '').match(/^Scanner (\d+)$/i);
                return match ? parseInt(match[1]) : 0;
            });
            const nextNum = numbers.length > 0 ? Math.max(...numbers) + 1 : 1;
            finalName = `Scanner ${nextNum}`;
        }

        const newScanner = await Scanner.create({
            uuid: scannerId,
            fingerprint: crypto.randomUUID(), // Immutable fingerprint (like serial number)
            name: finalName,
            status: 'ACTIVE',
            lastIp: ip,
            pairedAt: new Date(),
            deviceInfo: {
                userAgent: req.headers['user-agent'] || 'unknown'
            }
        });

        res.json({
            success: true,
            scannerId: newScanner.uuid,
            fingerprint: newScanner.fingerprint,
            name: newScanner.name,
            message: `Paired as ${newScanner.name}`,
            repairQR: {
                description: 'Use this QR to repair/reconnect this scanner in future',
                token: newScanner.fingerprint
            }
        });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Check if Scanner is Active (Heartbeat / Startup Check)
router.get('/check-scanner/:id', async (req, res) => {
    try {
        const scanner = await Scanner.findOne({ uuid: req.params.id });
        if (!scanner) return res.status(404).json({ valid: false });

        if (scanner.status === 'DISABLED') {
            return res.status(403).json({ valid: false, error: 'Scanner Disabled by Admin' });
        }

        // Update Last Seen
        scanner.lastSeen = new Date();

        // Update current employee if provided
        const employeeData = req.query.employee ? JSON.parse(req.query.employee) : null;
        if (employeeData && employeeData.employeeId) {
            scanner.currentEmployee = {
                employeeId: employeeData.employeeId,
                name: employeeData.name,
                loginAt: new Date()
            };
        }

        await scanner.save();

        res.json({
            valid: true,
            fingerprint: scanner.fingerprint,
            name: scanner.name
        });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Check for Already-Paired Device (used before pairing to detect duplicates)
// Frontend calls this to warn user if device is already paired
router.post('/check-device', async (req, res) => {
    try {
        const { ip, fingerprint } = req.body;

        // If fingerprint provided, check if this exact device is already paired
        if (fingerprint) {
            const scanner = await Scanner.findOne({ fingerprint, status: 'ACTIVE' });
            if (scanner) {
                return res.json({
                    alreadyPaired: true,
                    type: 'fingerprint',
                    name: scanner.name,
                    scannerId: scanner.uuid,
                    message: `This device is already paired as "${scanner.name}"`
                });
            }
        }

        // Check by IP (more lenient - detects if any device on this network is paired)
        const byIp = await Scanner.findOne({ lastIp: ip, status: 'ACTIVE' });
        if (byIp) {
            return res.json({
                alreadyPaired: true,
                type: 'ip',
                name: byIp.name,
                scannerId: byIp.uuid,
                fingerprint: byIp.fingerprint,
                message: `A device from this network is already paired as "${byIp.name}". Use repair link if this is the same device.`
            });
        }

        res.json({ alreadyPaired: false });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// --- 2. USER LOGIN (Human Layer) ---

router.post('/login', async (req, res) => {
    try {
        const { username, pin, password, scannerId } = req.body;
        const effectiveScannerId = scannerId || req.headers['x-scanner-id'];
        const credentialPin = pin || password;

        // 1. Validate Scanner First (Must be a trusted machine)
        const scanner = await Scanner.findOne({ uuid: effectiveScannerId });
        if (!scanner || scanner.status !== 'ACTIVE') {
            return res.status(403).json({ error: 'Unauthorized Scanner Device' });
        }

        // 2. Validate User
        // Case-insensitive user lookup
        const user = await User.findOne({
            username: { $regex: new RegExp(`^${username}$`, 'i') }
        });

        if (!user) {
            return res.status(401).json({ error: 'User not found' });
        }

        if (!(await comparePin(credentialPin, user.pin))) {
            return res.status(401).json({ error: 'Invalid PIN' });
        }

        // 3. Success - Return minimal session info
        // (In a full JWT system, give a token. Here we rely on trusted LAN + ScannerID header)
        res.json({
            success: true,
            user: {
                username: user.username,
                role: user.role
            }
        });

    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// Clear employee from scanner on logout
router.post('/logout', async (req, res) => {
    try {
        const { scannerId } = req.body;
        if (!scannerId) {
            return res.status(400).json({ error: 'Scanner ID required' });
        }

        const scanner = await Scanner.findOne({ uuid: scannerId });
        if (scanner) {
            scanner.currentEmployee = null;
            await scanner.save();
        }

        res.json({ success: true });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

module.exports = router;
